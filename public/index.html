<!DOCTYPE html>
<html>
  <head>
    <script lang="text/javascript" src="/socket.io/socket.io.js"></script>
    <script src="/simple-peer/simplepeer.min.js"></script>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="main-container">
      <!-- Left Chat Sidebar -->
      <div class="chat-sidebar">
        <div class="sidebar-header">
          <h2>VYANJAK</h2>
          <button class="collapse-btn" onclick="toggleSidebar()">
            <img
              src="assets/sidebar_close.svg"
              alt="Collapse"
              width="20"
              height="20"
              id="collapse-icon"
            />
          </button>
        </div>

        <div class="user-list">
          <div>
            <p style="margin-bottom: 3; margin-top: 0; text-align: center; font-size: 30px;">
              Select peers to chat
            </p>
          </div>
          <!-- User checkboxes will be populated here -->
          <div id="user-list" style="font-size: 30px;"></div>
        </div>
        <div class="chat-messages" id="chat-messages">
          <!-- Chat messages will appear here -->
        </div>
        <div class="chat-input">
          <input
            type="text"
            id="message-input"
            placeholder="Type your message..."
          />
          <button class=" sendButton" onclick="sendMessage()">
            <img
              id="sendIcon"
              src="assets/send.svg"
              alt="Send"
              width="24"
              height="24"
            />
          </button>
        </div>
      </div>

      <!-- Main Content Area -->
      <div class="content-area">
        <!-- Main Video Container -->
        <div class="video-container" id="videos">
          <!-- Remote video streams will be added here -->
        </div>

        <!-- Controls Bar -->
        <div class="controls-bar">
          <button class="settings hang-button" onclick="closeWindow()">
            <img
              id="hangIcon"
              src="assets/hang.svg"
              alt="Hang Up"
              width="24"
              height="24"
            />
          </button>

          <button id="muteButton" class="settings" onclick="toggleMute()">
            <img
              id="micIcon"
              src="assets/mic_mute.svg"
              alt="Mic"
              width="24"
              height="24"
            />
          </button>

          <button id="vidButton" class="settings" onclick="toggleVid()">
            <img
              id="videoIcon"
              src="assets/video_mute.svg"
              alt="Video"
              width="24"
              height="24"
            />
          </button>

          <select id="language" class="settings">
            <option value="en">English</option>
            <option value="hi">Hindi</option>
          </select>
          <button id="startBtn" class="settings">Speech to Text</button>
          <button id="stopBtn" class="settings" disabled>Stop</button>
        </div>
      </div>

      <!-- Local Video -->
      <video id="localVideo" autoplay muted></video>

      <!-- Transcription Box -->
      <div id="transcription-box">
        <div id="caption-head">Live Captions</div>
        <div class="transcription-text"></div>
      </div>
    </div>

    <footer>
      <script src="/js/main.js" lang="text/javascript"></script>
      <script>
        function toggleSidebar() {
          const sidebar = document.querySelector(".chat-sidebar");
          sidebar.classList.toggle("collapsed");

          if (sidebar.classList.contains("collapsed")) {
            sidebar.style.backgroundColor = "transparent"; 
          } else {
            sidebar.style.backgroundColor = "";
          }
        }

        function closeWindow() {
          window.close();
        }

        function sendMessageHandler() {
          // This will call the sendMessage function from main.js
          if (typeof sendMessage === "function") {
            sendMessage();
          } else {
            console.error("sendMessage function is not defined");
          }
        }
      </script>

      <script>
        // AudioWorklet processor code as a string
        const workletCode = `
      class AudioProcessor extends AudioWorkletProcessor {
          constructor() {
              super();
              this.bufferSize = 8192;
              this.buffer = new Float32Array(this.bufferSize);
              this.bufferedSamples = 0;
          }

          process(inputs, outputs, parameters) {
              const input = inputs[0][0];
              if (!input) return true;

              // Add incoming samples to buffer
              for (let i = 0; i < input.length; i++) {
                  this.buffer[this.bufferedSamples] = input[i];
                  this.bufferedSamples++;

                  // When buffer is full, send it to main thread
                  if (this.bufferedSamples >= this.bufferSize) {
                      const int16Data = new Int16Array(this.bufferSize);
                      for (let j = 0; j < this.bufferSize; j++) {
                          int16Data[j] = Math.max(-32768, Math.min(32767, this.buffer[j] * 32768));
                      }
                      this.port.postMessage(int16Data.buffer, [int16Data.buffer]);
                      
                      // Reset buffer
                      this.buffer = new Float32Array(this.bufferSize);
                      this.bufferedSamples = 0;
                  }
              }
              return true;
          }
      }
      registerProcessor('audio-processor', AudioProcessor);
  `;

        let websocket;
        let audioContext;
        let workletNode;
        const outputDiv = document.getElementById("output");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const languageSelect = document.getElementById("language");

        async function initAudioWorklet() {
          const blob = new Blob([workletCode], {
            type: "application/javascript",
          });
          const workletUrl = URL.createObjectURL(blob);
          await audioContext.audioWorklet.addModule(workletUrl);
          URL.revokeObjectURL(workletUrl);
        }

        startBtn.onclick = async () => {
          try {
            // Connect to WebSocket server
            websocket = new WebSocket("ws://localhost:8765");

            websocket.onopen = () => {
              websocket.send(
                JSON.stringify({
                  language: languageSelect.value,
                })
              );
            };

            websocket.onmessage = (event) => {
              const data = JSON.parse(event.data);
              if (data.type === "final") {
                // Only send to peers, don't display locally
                const transcriptionData = {
                  text: data.text,
                  sender: socket.id,
                  type: "transcription",
                };

                // Emit transcription to peers
                socket.emit("transcription", transcriptionData);
              }
            };

            // Get audio stream
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: true,
            });

            // Initialize audio context and worklet
            audioContext = new AudioContext({
              sampleRate: 8000, // Match Vosk's expected sample rate
              latencyHint: "interactive",
            });

            await initAudioWorklet();

            const source = audioContext.createMediaStreamSource(stream);
            workletNode = new AudioWorkletNode(audioContext, "audio-processor");

            workletNode.port.onmessage = (e) => {
              if (websocket.readyState === WebSocket.OPEN) {
                websocket.send(e.data);
              }
            };

            source.connect(workletNode);
            workletNode.connect(audioContext.destination);

            startBtn.disabled = true;
            stopBtn.disabled = false;
          } catch (error) {
            console.error("Error:", error);
            alert("Error starting recording: " + error.message);
          }
        };

        stopBtn.onclick = () => {
          if (websocket) {
            websocket.close();
          }
          if (workletNode) {
            workletNode.disconnect();
            workletNode = null;
          }
          if (audioContext) {
            audioContext.close();
            audioContext = null;
          }
          startBtn.disabled = false;
          stopBtn.disabled = true;
        };
      </script>
    </footer>
  </body>
</html>
